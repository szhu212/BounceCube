{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/game.js","webpack:///./src/index.js","webpack:///./src/level.js","webpack:///./src/player.js","webpack:///./src/util.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAA6B;AACF;AACwD;;AAEpE;;AAEf;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,6BAA6B,8CAAK;AAClC,8BAA8B,+CAAM;AACpC,+BAA+B,4CAAM;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;AACA,a;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,6BAA6B,WAAW;AACxC;;AAEA;AACA,6BAA6B,gBAAgB,GAAG,iBAAiB;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD,oCAAoC,oBAAoB;AACxD;AACA;AACA,6BAA6B,sDAAgB,oBAAoB;AACjE,+BAA+B,sDAAgB,oBAAoB;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,gDAAgD,4CAAM;AACtD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,kDAAkD,QAAQ,IAAI,QAAQ;AACtE;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAM;AACd;AACA,SAAS;;AAET;AACA;AACA,uCAAuC,4CAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAW;AAC3B,aAAa;AACb,S;AACA;;;;;AAKA,C;;;;;;;;;;;;ACrNA;AAAA;;;AAEA;AACA;AACA,QAAQ,6CAAI;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAqD;AACd;;AAExB;;AAEf;AACA;AACA,+CAA+C,4CAAM;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,qDAAO;AAC/B,0BAA0B,qDAAO;AACjC,wBAAwB,yBAAyB;AACjD,2BAA2B,4BAA4B;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,qCAAqC,+CAAS;AAC9C;AACA;AACA,mCAAmC,+CAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,2CAA2C,YAAY;AACvD;AACA,yCAAyC;AACzC;AACA,uBAAuB,sDAAQ;AAC/B;AACA;AACA;AACA,iEAAiE,WAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;;AAEA;;AAEA;AACA;AACA,eAAe,4CAAM;AACrB;;AAEA;AACA;AACA,oC;AACA;;;AAGA,C;;;;;;;;;;;;AC3FA;AAAA;AAAA;AAAkD;;AAEnC;;AAEf,4CAA4C;AAC5C;AACA,iBAAiB,+CAAS;AAC1B,0CAA0C,+CAAS;AACnD;AACA,sB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,+BAA+B,iBAAiB;AAChD,qCAAqC,+CAAS,eAAe,+CAAS;AACtE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;AACA;AACA;AACA;AACA,wC;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,0CAAI;AAC5B;AACA,8BAA8B,+CAAS;;AAEvC;AACA,wBAAwB,0CAAI,S;AAC5B;AACA,yBAAyB,+CAAS;AAClC;AACA,wBAAwB,0CAAI,S;AAC5B,0BAA0B,+CAAS;AACnC;AACA;AACA,iC;AACA;AACA,qBAAqB,+CAAS;AAC9B;AACA,yBAAyB,+CAAS;AAClC,S;AACA;AACA,yBAAyB,+CAAS;AAClC,SAAS;AACT,yBAAyB,+CAAS;AAClC;AACA;AACA,iCAAiC,+CAAS;AAC1C;AACA,gCAAgC,+CAAS;AACzC,iBAAiB;AACjB,sCAAsC,+CAAS;AAC/C;AACA;;AAEA,iCAAiC,+CAAS;AAC1C;AACA,4BAA4B,+CAAS;AACrC,aAAa;AACb,iCAAiC,+CAAS;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,UAAU;AACzC,iCAAiC,OAAO;AACxC;AACA;;AAEA,6CAA6C,+CAAS,gBAAgB,+CAAS;AAC/E,6CAA6C,+CAAS,gBAAgB,+CAAS;AAC/E,SAAS;AACT,qBAAqB,+CAAS;AAC9B;AACA,8CAA8C,+CAAS;AACvD,8CAA8C,+CAAS;AACvD,S;AACA;AACA;AACA,S;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,+CAAS;AACtC;AACA,6BAA6B,+CAAS;AACtC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAQ;AACxB;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,wCAAwC;;AAExC;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;AC1PO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK,GAAG,MAAM;AAChD;AACA,KAAK;AACL;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAK,GAAG,MAAM;AACpD;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,KAAK,GAAG,MAAM;AACnD;AACA,QAAQ;AACR;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,K;AACA;AACA;;AAEO;AACP,4CAA4C,yBAAyB;AACrE;AACA;AACA;AACA","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","import Player from \"./player\"\nimport Level from \"./level\"\nimport { levelInstruction, LEVELS, renderScores, scores, submitScore} from \"./util\"\n\nexport default class Game {\n\n    constructor(canvas){\n        this.ctx = canvas.getContext(\"2d\");\n        this.canvas = canvas\n        this.dimensions = { width: canvas.width, height: canvas.height };\n        this.keysTracker = {};\n        this.running = false;\n        this.currentLevel = 0 \n        this.totalTarget = 0 \n        this.registerEvents();\n        this.restart(this.currentLevel);\n        this.levelUp = false;\n        this.gameoverTracker = false;\n        this.scores = [];\n        this.highestScoreMode = false; \n        this.playingMusic = false;\n    }\n\n    play() {\n        this.running = true\n        if (Object.values(this.keysTracker).length > 0 && Object.values(this.keysTracker).some(val => val ===true))\n        {this.animate()};\n      }\n\n    restart(currentLevel) {\n        // debugger\n        // console.log(this.currentLevel)\n        this.gameoverTracker = false\n        if (!this.levelUp){\n            this.running = false;\n        }\n        this.startTime = this.startTime || Date.now();\n        this.textTimer = 0\n        // renderScores()\n        // renderScores()\n        // fetchScores()\n        this.numTargets = 1\n        if(this.gameover()){\n            // debugger\n            this.currentLevel = 0\n            this.gameoverTracker = true\n            this.gameoverFrame()\n        } else {\n            this.level = new Level(this.dimensions, currentLevel);\n            this.player = new Player(this.dimensions, this.keysTracker, this.level);\n            this.totalTarget = LEVELS[this.currentLevel].flat().filter(el => el ===2).length  \n            // debugger\n            this.animate();\n        }\n    }\n\n    keyDownHandler(e) {\n        this.keysTracker[e.keyCode] = true;\n        if (this.keysTracker[\"82\"]&& !this.highestScoreMode){\n            if (this.gameoverTracker){\n                this.currentLevel = 0\n                this.startTime = Date.now()\n                this.running = false\n                const gameoverPage = document.getElementById(\"gameover-box\")\n                gameoverPage.style.opacity = \"0\";   \n            }  \n                this.restart(this.currentLevel)\n        }\n        else if(!this.running && !this.highestScoreMode){\n            this.play()\n        }\n    }\n\n    keyUpHandler(e) {\n        this.keysTracker[e.keyCode] = false;\n    }\n    \n    registerEvents() {\n        this.keyDownHandler = this.keyDownHandler.bind(this);\n        this.keyUpHandler = this.keyUpHandler.bind(this);\n        document.addEventListener('keydown', (e) => {\n            this.keyDownHandler(e)\n        });\n        document.addEventListener('keyup', (e) => {\n            this.keyUpHandler(e)\n        });\n    }\n\n    drawTimer(){\n        this.timer = Math.floor((Date.now() - this.startTime)/1000)\n        if (this.textTimer === 0 && this.currentLevel === 0){this.timer = 0}\n        this.ctx.font = '20px Dosis'\n        this.ctx.fillStyle = 'rgb(255, 255, 255)';\n        this.ctx.fillText(`${this.timer}`, this.canvas.width -60, 20)\n    }\n\n    drawCounter(){\n        let counterText = `${this.numTargets}/${this.totalTarget}`\n        this.ctx.font = '20px Dosis'\n        this.ctx.fillStyle = 'rgb(255, 255, 255)';\n        this.ctx.fillText(counterText, this.canvas.width -60, 50)\n     }\n\n    animate() {\n        this.ctx.font = 'Dosis'\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n        this.level.animate(this.ctx, this.player)\n    \n        this.player.animate(this.ctx, this.keysTracker)\n        this.numTargets = this.level.numTargets\n        this.drawTimer()\n        this.drawText()\n        this.drawCounter()\n        if (this.numTargets === 0 && !this.gameoverTracker) {\n            this.currentLevel += 1;\n            this.levelUp = true;\n            this.restart(this.currentLevel)\n        }\n        if (this.running) {\n            requestAnimationFrame(this.animate.bind(this))\n        }\n    }\n\n\n    levelUpText(){\n        this.textTimer += 1\n        this.ctx.save()\n        this.ctx.font = '38px Dosis'\n        this.ctx.fillStyle = 'white';\n        this.ctx.strokeStyle = 'yellow'\n        this.ctx.fillText(`Level${this.currentLevel+1}`, this.canvas.width / 3, 100)\n        this.ctx.strokeText(`Level${this.currentLevel+1}`, this.canvas.width / 3, 100)\n        this.ctx.font = '28px Dosis';\n        this.ctx.strokeStyle = 'skyblue'\n        this.ctx.fillText(`${levelInstruction[this.currentLevel]}`, 200, 140);\n        this.ctx.strokeText(`${levelInstruction[this.currentLevel]}`, 200, 140);\n        this.ctx.restore();\n    }\n\n    drawText(){\n        if (this.textTimer ===0) {\n            this.ctx.save()\n            this.ctx.font = '25px Dosis'\n            // this.ctx.strokeStyle = 'blue'\n            this.ctx.fillStyle = 'rgba(255,255,255)';\n            this.ctx.shadowColor = 'rgba(0,0,0,0.7)'\n            this.ctx.shadowBlur = 5\n            this.ctx.fillText(\"Press the ↑ ← → buttons on your keyboard to navigate your cube\", this.canvas.width / 12,this.canvas.height *2/ 5, this.canvas.width * 5 / 6)\n            // this.ctx.strokeText(\"Press the ↑ ← → buttons on your keyboard to navigate your cube\", this.canvas.width / 12,this.canvas.height *2/ 5, this.canvas.width * 5 / 6)\n            this.ctx.restore();\n        }\n        if ((this.textTimer < 100 && this.currentLevel !== 0) || (this.currentLevel === 0 && this.textTimer < 100 && this.textTimer >0)){\n            this.levelUpText()\n        } else {\n            this.textTimer += 1\n        }\n    }\n\n    gameover(){\n        return this.currentLevel >= Object.keys(LEVELS).length\n    }\n\n    gameoverFrame(){\n       \n        let gameScore = this.timer\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n        const gamePage = document.getElementById('game-page')\n        gamePage.style.backgroundColor = 'orange'\n        const gameoverBox = document.getElementById('gameover-box')\n        gameoverBox.style.transition = 'all 1s ease-in-out;'\n        gameoverBox.style.opacity = 1;\n        let gameoverMessageP = document.createElement('p')\n        let minutes = Math.floor(this.timer / 60)\n        let seconds = Math.floor(this.timer % 60)\n        gameoverMessageP.innerHTML = `You spent ${minutes}M ${seconds}S to clear all levels. Congratulations!`\n        const  gameoverMessage = document.getElementById(\"gameover-messsage\")\n        gameoverMessage.innerHTML = '';\n        gameoverMessage.appendChild(gameoverMessageP)\n        document.getElementById(\"you-won-message\").style.animation = \"shake 0.5s\";\n        let highScores = []\n        scores.forEach(el => {\n            highScores.push(el.score) \n        })\n\n        let lowestRecord = Math.max(...highScores)\n        let name = ''\n        if(gameScore < lowestRecord || scores.length < 5 ) {\n            this.highestScoreMode = true\n            let recordSubmissionDiv = document.getElementById(\"record-submission\") \n            recordSubmissionDiv.innerHTML = ''\n            let highScoreMessageP = document.createElement('p')\n            highScoreMessageP.innerHTML = 'You score is among the top 5 in our history! Please enter you name to be on our Best Records board ☺' \n            recordSubmissionDiv.appendChild(highScoreMessageP)\n            let nameInput = document.createElement('input')\n            nameInput.type = 'text'\n            nameInput.placeholder = 'Please enter your name here'\n            recordSubmissionDiv.appendChild(nameInput)\n            nameInput.addEventListener('change', e => {\n                name = e.currentTarget.value;\n              });\n            let submitButton = document.createElement('button')\n            submitButton.innerHTML = 'Submit' \n            recordSubmissionDiv.appendChild(submitButton)\n            submitButton.addEventListener('click', e => {\n                this.highestScoreMode = false\n                submitScore(name, gameScore)\n            })\n        }  \n    }\n\n\n\n\n}","import Game from './game'; \n\ndocument.addEventListener('DOMContentLoaded', () => {\n    const canvas = document.getElementById(\"game-canvas\");\n    new Game(canvas)\n})\n\nconst musicButton = document.getElementById('music-button')\nconst musicIcon = document.getElementById('music-icon')\nconst music = new Audio('./bensound-summer.mp3') \nmusic.loop = true\nlet playingMusic = false\nmusicButton.addEventListener('click', handleMusic)\n\nfunction handleMusic() {\n    if (playingMusic){\n        playingMusic = false;\n        musicIcon.src = \"./play-music.png\"\n        music.pause()\n    } else {\n        playingMusic = true\n        musicIcon.src = \"./stop-music2.png\"\n        music.play()\n    }\n}","import { myCount, _overlap, CONSTANTS } from \"./util\"\nimport { LEVELS, colors } from \"./util\"\n\nexport default class Level {\n\n    constructor(dimensions, currentLevel){\n        this.dimensions = dimensions;\n        this.level = JSON.parse(JSON.stringify(LEVELS))[currentLevel];\n        this.currentLevel = currentLevel;\n        // this.bricks = [];\n        this.bricks = {};\n        this.targetLength = 10;\n        this.targets = {};\n        this.numTargets = 0;\n        this.color = '0,92,175';\n        // debugger\n    };\n \n    drawLevel(ctx, player) {\n        const wallWidth = this.dimensions.width / this.level[0].length\n        const wallHeight = this.dimensions.height / this.level.length\n        // debugger\n        let numBricks = myCount(this.level.flat(), 1)\n        this.numTargets = myCount(this.level.flat(), 2)\n        for(let row = 0; row < this.level.length; row ++){\n            for(let col= 0; col < this.level[0].length; col++){\n                let leftStart = col * wallWidth;\n                let upStart = row * wallHeight\n                \n                if(this.level[row][col] === 1){\n                    const image = new Image();\n                    image.src = './brick.png';\n                    // debugger\n                    image.onload = function () {\n                        ctx.drawImage(image, leftStart, upStart, wallWidth, wallHeight);\n                    }\n                    ctx.drawImage(image, leftStart, upStart, wallWidth, wallHeight);\n                   this.bricks[[row, col]] = {left : leftStart, top:upStart, right : (leftStart + wallWidth), bottom : (upStart + wallHeight)}\n                }\n                else if(this.level[row][col] === 2){\n                    // debugger\n                    if(col === 0) {\n                        leftStart += CONSTANTS.BOARDER_WIDTH\n                    }\n                    if(row === this.level.length){\n                        upStart -= CONSTANTS.BOARDER_WIDTH\n                    }\n                    let targetColor\n                    // debugger\n                    let pos = row + ',' + col\n                    if (Object.keys(this.targets).includes(pos)){\n                        targetColor = this.targets[[row,col]]\n                    } else {\n                        targetColor = this.randomColor()\n                    }\n                    ctx.fillStyle = `rgb(${targetColor})`\n                    ctx.fillRect(leftStart, upStart, this.targetLength, this.targetLength)\n                    let currentTarget = {left : leftStart, top:upStart, right : (leftStart + this.targetLength), bottom : (upStart + this.targetLength), color: targetColor}\n                    this.targets[[row, col]] = targetColor\n                    if(_overlap(player.bounds(), currentTarget)){\n                        this.level[row][col] = 0\n                        this.color = currentTarget.color\n                        const gamePage = document.getElementById('game-page')\n                        gamePage.style.backgroundColor = `rgba(${this.color}, 0.6)`\n                    }\n                }\n            }\n        }\n        // debugger\n    }\n\n    drawBackground(ctx){\n        // debugger\n        ctx.fillStyle = \"rgba(255,255,255,0.4)\"\n        ctx.fillRect(0, 0, this.dimensions.width, this.dimensions.height);\n        // ctx.fillStyle = `rgba(${this.color}, 0.2)`;\n        // ctx.fillRect(0, 0, this.dimensions.width, this.dimensions.height);\n        \n    }\n\n    randomColor(){\n        let num = Math.floor(Math.random() * 15)\n        return colors[num]\n    }\n\n    animate(ctx, player) {\n        this.drawBackground(ctx);\n        this.drawLevel(ctx, player);    \n    }\n   \n\n}","import { _overlap, CONSTANTS, KEYS } from \"./util\"\n\nexport default class Player {\n\n    constructor(dimensions, keysTracker = {}, level) {\n        this.dimensions = dimensions;\n        this.x = CONSTANTS.BOARDER_WIDTH;\n        this.y = this.dimensions.height - CONSTANTS.EDGE //- CONSTANTS.BOARDER_WIDTH;\n        this.velX = 0;\n        this.velY = 0; \n        this.keysTracker = keysTracker;\n        this.level = level;\n        // this.onGround = false;\n        this.collisionAdj = 0;\n    }\n\n\n    drawPlayer(ctx) {\n        ctx.fillStyle = `rgb(${this.level.color})`;\n        ctx.fillRect(this.x, this.y, CONSTANTS.PLAYER_WIDTH, CONSTANTS.PLAYER_HEIGHT);\n    }\n\n    // pushPlayer(keysTracker){\n    //     // debugger\n    //     if (keysTracker[KEYS.UP]){\n    //         // this.onGround = false;\n    //         this.velY -= 1 * CONSTANTS.UP_SPEED \n    //         if (this.velY < -CONSTANTS.MAX_SPEED) {\n    //             this.velY = -CONSTANTS.MAX_SPEED\n    //         }\n    //     }\n    //     if (keysTracker[KEYS.LEFT]) {  \n    //         // debugger          \n    //         this.velX -= CONSTANTS.HORIZENTAL_SPEED \n    //     }\n    //     if (keysTracker[KEYS.RIGHT]){         \n    //         this.velX +=  CONSTANTS.HORIZENTAL_SPEED\n    //     }\n    // }\n\n    updatePlayer(keysTracker) {\n        if (keysTracker[KEYS.UP]){\n            // this.onGround = false;\n             this.velY -= 1 * CONSTANTS.UP_SPEED \n             \n        }\n        if (keysTracker[KEYS.LEFT]) {  \n            // debugger          \n            this.velX -= CONSTANTS.HORIZENTAL_SPEED \n        }\n        if (keysTracker[KEYS.RIGHT]){         \n            this.velX +=  CONSTANTS.HORIZENTAL_SPEED\n        }\n        // console.log(this.x, this.y)\n        // this.onGround = false;           \n    // debugger\n        this.velX *= CONSTANTS.FRICTION  \n        if(this.y < 390){\n            this.velY += CONSTANTS.GRAVITY \n        }   \n        if(this.velY > 0){\n            this.velY -= CONSTANTS.AIR_FRICTION \n        } else {\n            this.velY += CONSTANTS.AIR_FRICTION\n        }\n        // debugger    \n        if(Math.abs(this.velX) > CONSTANTS.MAX_SPEED){\n                if(this.velX > 0) {\n                    this.velX = CONSTANTS.MAX_SPEED\n                } else {\n                    this.velX = - 1 * CONSTANTS.MAX_SPEED\n                }\n        }\n        \n        if(Math.abs(this.velY) > CONSTANTS.MAX_SPEED){\n            if(this.velY > 0) {\n                this.velY = CONSTANTS.MAX_SPEED\n            } else {\n                this.velY = -1 * CONSTANTS.MAX_SPEED\n            }\n        }\n\n        if (this.collideWithBrick()){\n            this.resolveCollision()\n        }\n\n    // if(this.onGround) {\n    //     this.velY = 0;\n    // }\n\n        // console.log(`velY ${this.velY}`)\n        // console.log(`this.y ${this.y}`)\n        this.x += this.velX\n        this.y += this.velY\n\n        if (this.x > this.dimensions.width - CONSTANTS.PLAYER_WIDTH - CONSTANTS.BOARDER_WIDTH) {\n            this.x = this.dimensions.width - CONSTANTS.PLAYER_WIDTH - CONSTANTS.BOARDER_WIDTH\n        }  else if (this.x < 0) {\n            this.x = CONSTANTS.BOARDER_WIDTH\n        }\n        if (this.y > this.dimensions.height - CONSTANTS.PLAYER_HEIGHT) {\n            this.y = this.dimensions.height - CONSTANTS.PLAYER_HEIGHT\n        }  \n        else if (this.y < 0) {\n            this.y = 0\n        }    \n    }\n\n    bounds(){\n        return {\n            left: this.x,\n            right: (this.x + CONSTANTS.PLAYER_WIDTH), \n            top: this.y, \n            bottom: (this.y +CONSTANTS.PLAYER_HEIGHT)\n        }\n    }\n\n    animate(ctx, keysTracker) {\n        this.updatePlayer(keysTracker);\n        // this.pushPlayer(keysTracker);\n        this.drawPlayer(ctx);\n      \n    }\n\n    collideWithBrick(){\n        let collision = false;\n        // debugger\n        Object.values(this.level.bricks).forEach(\n            brick => {\n            if (_overlap(brick, this.bounds())){\n                collision = true;\n            }\n            })\n        return collision;\n    }\n\n    // collisionDir(){\n    //     let collisionType = [null, null];\n    //     if(!this.collideWithBrick()){return collisionType}\n\n    //     const _overlapDir = (rect1, rect2) => {\n    //         if (rect1.right >= rect2.left && rect1.right <= (rect2.left + rect2.right)/2){\n    //             collisionType[0] =\"left\"\n    //         } else if (rect1.left <= rect2.right && rect1.left <= (rect2.left + rect2.right)/2){\n    //             collisionType[0] = \"right\"\n    //         }\n    //         if(rect1.bottom <= rect2.top && rect1.bottom >= (rect2.top + rect2.bottom)/2){\n    //             collisionType[1] = \"top\"\n    //         } else if (rect1.top <= rect2.bottom && rect1.top <= (rect2.top + rect2.bottom)/2) {\n    //             collisionType[1] = \"bottom\"\n    //         }\n    //     }\n\n    //     this.level.bricks.forEach(brick => {\n    //         _overlapDir(this.bounds(), brick)\n    //     })\n    //     console.log(collisionType)\n    //     return collisionType;\n    // }\n\n    collisionDir(){\n        let collisionDir = [null, null]\n        const _overlapDir = (rect1, rect2) => {\n            const width1 = rect1.right - rect1.left\n            const width2 = rect2.right - rect2.left\n            const height1 = rect1.bottom - rect1.top\n            const height2 = rect2.bottom - rect2.top\n            const centerDistX = (rect1.left + rect1.right)/2 - (rect2.left + rect2.right)/2\n            const centerDistY = (rect1.bottom + rect1.top)/2 - (rect2.bottom + rect2.top)/2\n            const avrWidth = (width1 + width2)/2\n            const avrHeight = (height1 + height2)/2\n            const distX = avrWidth - Math.abs(centerDistX)\n            const distY = avrHeight - Math.abs(centerDistY)\n\n           \n            if (Math.abs(centerDistX) < avrWidth && Math.abs(centerDistY) < avrHeight){\n                if (distX >= distY){\n                    if (centerDistY > 0){\n                        collisionDir[1] = \"top\";\n                        this.collisionAdj = distY\n                    }\n                    else {\n                        collisionDir[1] = \"bottom\";\n                        // rect1.y -= distY;\n                       \n                        // console.log(rect1.y)\n                        this.collisionAdj = -distY\n                    }\n                }\n                else {\n                    if(centerDistX < 0){\n                        collisionDir[0] = \"right\";\n                        this.collisionAdj = -distX\n                    } else {\n                        collisionDir[0] = \"left\";\n                        this.collisionAdj = distX\n                    }\n                }\n            }\n        }\n\n        Object.values(this.level.bricks).forEach(\n            brick => {\n            _overlapDir(this.bounds(), brick)\n        })\n        return collisionDir\n    }\n\n    resolveCollision(){\n        // console.log(this.collisionDir())\n        if (this.collideWithBrick()){\n            if (this.collisionDir()[0] === \"right\"){\n                this.x += this.collisionAdj\n                if(this.velX !== 0) {\n                    this.velX *= -1\n                } else {\n                    this.velX = 0.1\n                }\n            }\n\n            if (this.collisionDir()[0] === \"left\"){\n                this.x += this.collisionAdj\n                if(this.velX !== 0) {\n                    this.velX *= -1\n                } else {\n                    this.velX = -0.1\n                }\n            }\n            if (this.collisionDir()[1] === \"top\"){\n                    this.y += this.collisionAdj\n                    this.velY *= -1\n            }\n            if (this.collisionDir()[1] === \"bottom\"){\n                this.y += this.collisionAdj\n                // this.onGround = true;\n                 if(this.velY<0 && this.velY > -2){\n                this.velY =0 \n               } else {\n                     this.velY *= -1\n                }\n                 this.bottomCollision = true \n\n            }\n            this.collisionAdj = 0\n        }\n\n    }\n\n\n    \n\n}\n\n","\nexport const CONSTANTS = {\n    GRAVITY: 0.8,\n    FRICTION: 0.8,\n    AIR_FRICTION: 0.4,\n    PLAYER_WIDTH: 15,\n    PLAYER_HEIGHT: 15,\n    UP_SPEED: 2,\n    HORIZENTAL_SPEED: 1,\n    MAX_SPEED: 4,\n    EDGE: 10,\n    BOARDER_WIDTH : 0\n}\n\nexport const KEYS = {\n    UP: 38,\n    LEFT: 37,\n    RIGHT: 39\n}\n\nexport const LEVELS = {\n    0: [\n        [1,1,1,1,1,0,0],\n        [1,0,0,0,0,0,0],\n        [0,0,0,0,0,0,2],\n        [0,2,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [1,1,1,0,0,0,0],\n        [0,0,0,2,0,0,0],\n        [0,0,0,0,0,0,0],\n        [2,0,0,0,0,0,0],\n        [0,0,0,0,0,2,0],\n        [0,0,1,1,1,0,0]\n    ],\n    1: [\n        [1,1,1,1,1,0,0],\n        [0,0,0,0,0,0,2],\n        [1,1,0,0,0,0,0],\n        [0,0,0,0,0,2,1],\n        [0,0,0,0,0,1,1],\n        [1,1,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,2,0,0,0,0],\n        [0,2,0,0,0,0,0],\n        [0,0,1,1,1,0,0]\n    ],\n    2: [\n        [1,1,1,1,1,1,1,1,1,1],\n        [0,0,0,0,0,0,2,0,0,1],\n        [0,0,1,0,0,0,0,0,0,1],\n        [1,0,1,1,1,1,1,1,1,1],\n        [1,0,0,0,0,2,0,0,0,0],\n        [1,0,0,2,0,0,0,0,0,0],\n        [1,0,0,0,0,0,0,0,0,0],\n        [1,1,1,1,1,1,1,1,0,0],\n        [0,0,2,0,0,0,1,0,0,1],\n        [0,2,0,0,0,0,0,0,0,1],\n        [0,0,1,1,1,1,1,1,1,1]\n    ],\n    3: [\n        [0,1,1,1,0,0,1,0,2],\n        [0,1,2,1,0,2,0,0,1],\n        [0,1,0,1,0,1,0,1,0],\n        [0,1,0,0,0,0,2,1,0],\n        [0,1,0,1,0,0,1,1,0],\n        [0,1,0,1,0,0,1,0,0],\n        [0,1,0,1,0,0,0,2,0],\n        [0,0,0,1,0,0,0,1,0],\n        [0,1,2,1,0,0,1,1,2],\n        [0,1,0,1,0,0,0,1,0],\n        [0,1,1,1,0,1,0,1,0]\n    ],\n    3: [\n        [0,0,0,0,0,0,0,0,2,0],\n        [0,1,1,1,0,1,1,1,1,0],\n        [0,1,2,1,0,1,0,2,1,0],\n        [0,1,0,0,0,0,0,1,2,0],\n        [0,1,0,0,0,0,0,1,0,0],\n        [0,1,1,1,0,0,1,0,0,0],\n        [0,0,0,1,0,0,1,2,0,0],\n        [0,0,0,1,0,0,1,0,0,0],\n        [0,0,2,1,0,1,0,0,2,0],\n        [0,1,0,1,0,1,0,0,1,0],\n        [0,1,1,1,0,1,1,1,1,0]\n    ]\n}\n\n\nexport const levelInstruction = {\n    0: \"Have Fun!\",\n    1: \"Level up. Great Job!\",\n    2: \"Level up. You Rock!\",\n    3: \"Level Up. Getting Harder!\"\n}\n\nexport const colors = {\n    0: \"255, 186, 132\",\n    1: \"98, 41, 84\",\n    2: \"137, 145, 107\",\n    3: \"145, 180, 147\",\n    4: \"102, 186, 183\",\n    5: \"30, 136, 168\",\n    6: \"123, 144, 210\",\n    7: \"155, 144, 194\",\n    8: \"238, 169, 169\",\n    9: \"93, 172, 129\" ,\n    10: \"24, 60, 138\",\n    11: \"208, 16, 76\",\n    12: \"253, 153, 102\",\n    13: \"190, 194, 63\",\n    14: \"180, 129, 187\"\n}\n\n\nexport const _overlap = (rect1, rect2) => {\n    if (rect1.left > rect2.right || rect1.right < rect2.left) {\n        return false;\n    }\n    if (rect1.top > rect2.bottom || rect1.bottom < rect2.top){\n        return false;\n    }\n    return true;\n}\n\nexport const myCount = (arr, target) => {\n    return arr.filter(el => el === target).length\n}\n\n// export const fetchScores = () => {\n//     // const scores = []\n//    let scores\n//    let fetchedData = firebase.database().ref('scores').orderByChild('score').limitToFirst(5)\n//    fetchedData.on('value', dataSnapshot => {\n//         scores = dataSnapshot.val()\n//    })\n//    let keys = Object.keys(scores)\n// //    debugger\n// //    let vals = []\n// //    scores.forEach(el => {\n// //        vals.push(Object.values(el))\n// //    })\n//    return scores\n// }\n\n// let fetchedData = firebase.database().ref('scores').orderByChild('score').limitToFirst(5)\n\n\n\n// fetchedData.on('child_added', dataSnapshot => {\n//     console.log(dataSnapshot.val())\n//     scores.push(dataSnapshot.val())\n//         // scores = dataSnapshot.val()\n// //         console.log(dataSnapshot.val())\n// })\n\n// export async function fetchScores (){\n//     let fetchedData = firebase.database().ref('scores').orderByChild('score').limitToFirst(5)\n//     let valsObj = fetchedData.once('value')\n//     let vals = Object.values(valsObj.val())\n//     return vals\n// }\n\nlet fetchScores = firebase.database().ref('scores').orderByChild('score').limitToFirst(5)\nexport const scores = []\n \nfetchScores.on('child_added', snapshot => {\n    scores.push(snapshot.val())\n    let highScoreDiv = document.getElementById('high-scores')\n    highScoreDiv.innerHTML = \"\"\n    scores.sort(compare)\n    scores.forEach(el=> {\n        let name = el.name\n        let score = el.score\n        let highScoreP = document.createElement('p')\n        highScoreP.innerHTML = `${name} ${score}s`\n        highScoreDiv.appendChild(highScoreP)\n    })\n    // console.log('hiii')\n})\n\nexport async function renderScores () {\n    let asyncFetchScores = firebase.database().ref('scores').orderByChild('score').limitToFirst(5)\n    let asyncScores = []\n    let vals = await asyncScores\n    asyncFetchScores.on('child_added', snapshot => {\n        asyncScores.push(snapshot.val())\n        let highScoreDiv = document.getElementById('high-scores')\n        highScoreDiv.innerHTML = \"\"\n        vals.sort(compare)\n        vals.forEach(el=> {\n            let name = el.name\n            let score = el.score\n            let highScoreP = document.createElement('p')\n            highScoreP.innerHTML = `${name} ${score}s`\n            highScoreDiv.appendChild(highScoreP)\n        })\n        // console.log('hiii')\n    })\n    // let highScoreDiv = document.getElementById('high-scores')\n    // highScoreDiv.innerHTML = \"\"\n    // vals.sort(compare)\n    // vals.forEach(el=> {\n    //     let name = el.name\n    //     let score = el.score\n    //     let highScoreP = document.createElement('p')\n    //     highScoreP.innerHTML = `${name} ${score}s`\n    //     highScoreDiv.appendChild(highScoreP)\n    // })\n}\n\nconst compare = (a, b) => {\n    const scoreA = a.score\n    const scoreB = b.score\n\n    let comparison = 0\n    if (scoreA > scoreB) {\n        comparison = 1\n    } else if (scoreA < scoreB){\n        comparison = -1\n    } \n    return comparison\n}\n\nexport const submitScore = (name, score) => {\n    firebase.database().ref('scores').push({name: name, score: score})\n    let recordSubmissionDiv = document.getElementById(\"record-submission\") \n    recordSubmissionDiv.innerHTML = ''\n    renderScores()\n}\n"],"sourceRoot":""}